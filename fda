use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use futures::{channel::mpsc, StreamExt};
use libp2p::{
    gossipsub::{self, IdentTopic, MessageAuthenticity, MessageId},
    mdns, noise,
    swarm::{NetworkBehaviour, SwarmEvent},
    tcp, yamux, PeerId,
};
use rand::Rng;
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use std::{
    collections::hash_map::DefaultHasher,
    error::Error,
    hash::{Hash, Hasher},
    sync::{mpsc::Receiver, Arc, Mutex},
    time::Duration,
};
use tokio::{io, select};
use tracing_subscriber::EnvFilter;

// Definimos una estructura para los mensajes del protocolo
#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum ProtocolMessage {
    RandomNumber(String),
    PublicKey(Vec<u8>),
    Proof(Vec<u8>),
    RevealToken(Vec<u8>),
    Card(Vec<u8>),
    Action(GameAction),
    // Otros tipos de mensajes específicos del protocolo pueden añadirse aquí
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum GameAction {
    Bet(u64),
    Check,
    Fold,
    Call,
    Raise(u64),
}

// Estructura para la conexión P2P
pub struct P2PConnection {
    sender: mpsc::Sender<ProtocolMessage>,
    receiver: Arc<Mutex<mpsc::Receiver<(PeerId, ProtocolMessage)>>>,
    peer_id: PeerId,
    rnd_message: String,
}

// El comportamiento de red combina Gossipsub y mDNS
#[derive(NetworkBehaviour)]
struct MyBehaviour {
    gossipsub: gossipsub::Behaviour,
    mdns: mdns::tokio::Behaviour,
}

impl P2PConnection {
    // Inicializa la conexión P2P
    pub async fn init() -> Result<Self, Box<dyn Error>> {
        let _ = tracing_subscriber::fmt()
            .with_env_filter(EnvFilter::from_default_env())
            .try_init();

        // Canales para comunicación con la aplicación principal
        let (to_swarm_tx, mut to_swarm_rx) = mpsc::channel(32);
        let (mut from_swarm_tx, from_swarm_rx) = mpsc::channel(32);

        let from_swarm_rx = Arc::new(Mutex::new(from_swarm_rx));

        let mut rng = rand::rng();
        let random_number = rng.random_range(0..1000);

        let rnd_message = format!("Random number: {}", random_number);
        println!("Random number: {}", random_number);
        // Crear y configurar el swarm
        let mut swarm = libp2p::SwarmBuilder::with_new_identity()
            .with_tokio()
            .with_tcp(
                tcp::Config::default(),
                noise::Config::new,
                yamux::Config::default,
            )?
            .with_quic()
            .with_behaviour(|key| {
                let message_id_fn = |message: &gossipsub::Message| {
                    let mut s = DefaultHasher::new();
                    message.data.hash(&mut s);
                    MessageId::from(s.finish().to_string())
                };

                let gossipsub_config = gossipsub::ConfigBuilder::default()
                    .heartbeat_interval(Duration::from_secs(10))
                    .validation_mode(gossipsub::ValidationMode::Strict)
                    .message_id_fn(message_id_fn)
                    .build()
                    .map_err(|msg| io::Error::new(io::ErrorKind::Other, msg))?;

                let gossipsub = gossipsub::Behaviour::new(
                    MessageAuthenticity::Signed(key.clone()),
                    gossipsub_config,
                )?;

                let mdns = mdns::tokio::Behaviour::new(
                    mdns::Config::default(),
                    key.public().to_peer_id(),
                )?;
                Ok(MyBehaviour { gossipsub, mdns })
            })?
            .build();

        let topic = IdentTopic::new("texas-holdem");
        swarm.behaviour_mut().gossipsub.subscribe(&topic)?;

        // Configurar listeners
        swarm.listen_on("/ip4/0.0.0.0/udp/0/quic-v1".parse()?)?;
        swarm.listen_on("/ip4/0.0.0.0/tcp/0".parse()?)?;

        let peer_id = *swarm.local_peer_id();
        println!("Local peer ID: {}", peer_id);

        // Iniciar el bucle principal en un hilo separado
        let swarm_topic = topic.clone();

        let to_swarm_tx_clone = to_swarm_tx.clone();
        let from_swarm_rx_clone = from_swarm_rx.clone();
        let rnd_message_clone = rnd_message.clone();
        tokio::spawn(async move {
            loop {
                select! {
                    message = to_swarm_rx.next() => {
                        if let Some(message) = message {
                            let serialized = serde_json::to_string(&message).unwrap();
                            if let Err(e) = swarm
                                .behaviour_mut().gossipsub
                                .publish(swarm_topic.clone(), serialized.as_bytes()) {
                                println!("Publish error: {e:?}");
                            }
                        }
                    }
                    event = swarm.select_next_some() => match event {
                        SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Discovered(list))) => {
                            for (peer_id, _multiaddr) in list {
                                println!("mDNS discovered a new peer: {peer_id}");
                                to_swarm_tx_clone.clone().try_send(ProtocolMessage::RandomNumber(rnd_message_clone.clone()));
                                let mut receiver = from_swarm_rx_clone.lock().unwrap();
                                let message = futures::executor::block_on(receiver.next());
                                println!("Message: {:?}", message);
                                // Esperar a recibir un mensaje de otro usuario
                                if let Some((peer_id, ProtocolMessage::RandomNumber(other_number))) = message {
                                    // Comparar los números
                                    let other_number_value: u64 = other_number.parse().unwrap_or(0);
                                    let rnd_number_value: u64 = rnd_message_clone.parse().unwrap_or(0);

                                    if rnd_number_value > other_number_value {
                                        println!("El número más alto es el mío: {}", rnd_number_value);
                                    } else if rnd_number_value < other_number_value {
                                        println!("El número más alto es el del otro usuario: {}", other_number_value);
                                    } else {
                                        println!("Ambos números son iguales: {}", rnd_number_value);
                                    }
                                }

                                swarm.behaviour_mut().gossipsub.add_explicit_peer(&peer_id);
                            }
                        },
                        SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Expired(list))) => {
                            for (peer_id, _multiaddr) in list {
                                println!("mDNS discover peer has expired: {peer_id}");
                                swarm.behaviour_mut().gossipsub.remove_explicit_peer(&peer_id);
                            }
                        },
                        SwarmEvent::Behaviour(MyBehaviourEvent::Gossipsub(gossipsub::Event::Message {
                            propagation_source: peer_id,
                            message_id: _id,
                            message,
                        })) => {
                            match serde_json::from_slice::<ProtocolMessage>(&message.data) {
                                Ok(protocol_message) => {
                                    println!("Received message from {}: {:?}", peer_id, protocol_message);
                                    if let Err(e) = from_swarm_tx.try_send((peer_id, protocol_message)) {
                                        println!("Error forwarding message: {:?}", e);
                                    }
                                },
                                Err(e) => println!("Error deserializing message: {:?}", e),
                            }
                        },
                        SwarmEvent::NewListenAddr { address, .. } => {
                            println!("Local node is listening on {address}");
                        }
                        _ => {}
                    }
                }
            }
        });

        Ok(Self {
            sender: to_swarm_tx,
            receiver: from_swarm_rx,
            peer_id,
            rnd_message: rnd_message,
        })
    }

    // Obtener el peer ID local
    pub fn local_peer_id(&self) -> PeerId {
        self.peer_id
    }

    // Enviar un mensaje del protocolo
    pub async fn send_message(&self, message: ProtocolMessage) -> Result<(), Box<dyn Error>> {
        self.sender.clone().try_send(message)?;
        Ok(())
    }

    // Enviar una clave pública
    pub async fn send_public_key(&self, public_key: &[u8]) -> Result<(), Box<dyn Error>> {
        self.send_message(ProtocolMessage::PublicKey(public_key.to_vec()))
            .await
    }

    // Enviar una prueba
    pub async fn send_proof(&self, proof: &[u8]) -> Result<(), Box<dyn Error>> {
        self.send_message(ProtocolMessage::Proof(proof.to_vec()))
            .await
    }

    // Enviar un token de revelación
    pub async fn send_reveal_token(&self, token: &[u8]) -> Result<(), Box<dyn Error>> {
        self.send_message(ProtocolMessage::RevealToken(token.to_vec()))
            .await
    }

    // Enviar una carta
    pub async fn send_card(&self, card: &[u8]) -> Result<(), Box<dyn Error>> {
        self.send_message(ProtocolMessage::Card(card.to_vec()))
            .await
    }

    // Enviar una acción del juego
    pub async fn send_action(&self, action: GameAction) -> Result<(), Box<dyn Error>> {
        self.send_message(ProtocolMessage::Action(action)).await
    }

    // Recibir un mensaje (bloquea hasta recibir uno)
    pub async fn receive_message(&self) -> Option<(PeerId, ProtocolMessage)> {
        let mut receiver = self.receiver.lock().unwrap();
        futures::executor::block_on(receiver.next())
    }


    // Recibir un tipo específico de mensaje (bloquea hasta recibir uno del tipo deseado)
    pub async fn receive_specific<T, F>(&self, extractor: F) -> Option<(PeerId, T)>
    where
        F: Fn(&ProtocolMessage) -> Option<T>,
        T: Clone,
    {
        loop {
            if let Some((peer_id, message)) = self.receive_message().await {
                if let Some(extracted) = extractor(&message) {
                    return Some((peer_id, extracted));
                }
            } else {
                return None;
            }
        }
    }

    // Función específica para recibir una clave pública
    pub async fn receive_public_key(&self) -> Option<(PeerId, Vec<u8>)> {
        self.receive_specific(|msg| {
            if let ProtocolMessage::PublicKey(key) = msg {
                Some(key.clone())
            } else {
                None
            }
        })
        .await
    }

    // Función específica para recibir una prueba
    pub async fn receive_proof(&self) -> Option<(PeerId, Vec<u8>)> {
        self.receive_specific(|msg| {
            if let ProtocolMessage::Proof(proof) = msg {
                Some(proof.clone())
            } else {
                None
            }
        })
        .await
    }

    // Función específica para recibir un token de revelación
    pub async fn receive_reveal_token(&self) -> Option<(PeerId, Vec<u8>)> {
        self.receive_specific(|msg| {
            if let ProtocolMessage::RevealToken(token) = msg {
                Some(token.clone())
            } else {
                None
            }
        })
        .await
    }

    // Función específica para recibir una carta
    pub async fn receive_card(&self) -> Option<(PeerId, Vec<u8>)> {
        self.receive_specific(|msg| {
            if let ProtocolMessage::Card(card) = msg {
                Some(card.clone())
            } else {
                None
            }
        })
        .await
    }

    // Función específica para recibir una acción del juego
    pub async fn receive_action(&self) -> Option<(PeerId, GameAction)> {
        self.receive_specific(|msg| {
            if let ProtocolMessage::Action(action) = msg {
                Some(action.clone())
            } else {
                None
            }
        })
        .await
    }

    // Función de utilidad para convertir cualquier struct serializable en bytes
    pub fn serialize<T: Serialize>(data: &T) -> Result<Vec<u8>, Box<dyn Error>> {
        Ok(serde_json::to_vec(data)?)
    }

    pub fn serialize_canonical<T: CanonicalSerialize>(data: &T) -> Result<Vec<u8>, Box<dyn Error>> {
        let mut buffer = Vec::new();
        data.serialize(&mut buffer)?;
        Ok(buffer)
    }
    // Función de utilidad para convertir bytes en un struct deserializable
    pub fn deserialize<T: DeserializeOwned>(bytes: &[u8]) -> Result<T, Box<dyn Error>> {
        Ok(serde_json::from_slice(bytes)?)
    }

    pub fn deserialize_canonical<T: CanonicalDeserialize>(
        bytes: &[u8],
    ) -> Result<T, Box<dyn Error>> {
        let mut reader = &bytes[..];
        let value = T::deserialize(&mut reader)?;
        Ok(value)
    }
}
