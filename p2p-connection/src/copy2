use std::{
    collections::hash_map::DefaultHasher,
    collections::HashMap,
    env,
    error::Error,
    hash::{Hash, Hasher},
    sync::Arc,
    time::Duration,
};

use tokio::sync::Mutex;
use tokio::sync::MutexGuard;

use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use futures::{channel::mpsc, StreamExt};
use libp2p::{
    gossipsub::{self, IdentTopic, MessageAuthenticity, MessageId},
    mdns, noise,
    swarm::{NetworkBehaviour, Swarm, SwarmEvent},
    tcp, yamux, PeerId,
};
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use tokio::{io, select};
use tracing_subscriber::EnvFilter;

// Definimos una estructura para los mensajes del protocolo
#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum ProtocolMessage {
    PublicKey(Vec<u8>),
    Proof(Vec<u8>),
    RevealToken(Vec<u8>),
    Card(Vec<u8>),
    Action(GameAction),
    // Otros tipos de mensajes espec√≠ficos del protocolo pueden a√±adirse aqu√≠
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum GameAction {
    Bet(u64),
    Check,
    Fold,
    Call,
    Raise(u64),
}


struct Events {
    listeners: HashMap<String, Vec<Arc<Mutex<dyn FnMut(&str) + Send + Sync + 'static>>>>,
}

impl Events {
    fn new() -> Self {
        Self {
            listeners: HashMap::new(),
        }
    }

    fn on<F>(&mut self, event: &str, callback: F)
    where
        F: Fn(&str) + Send + Sync + 'static,
    {
        self.listeners
            .entry(event.to_string())
            .or_default()
            .push(Arc::new(Mutex::new(callback)));
        
        }

    // fn emit(&self, event: &str, data: &str) {
    //     if let Some(callbacks) = self.listeners.get(event) {
    //         for callback in callbacks {
    //             callback(data);
    //         }
    //     }
    // }

    fn emit(&self, event: &str, data: &str) {
        if let Some(callbacks) = self.listeners.get(event) {
            for callback in callbacks.iter() {
                let callback = Arc::clone(callback);
                let data = data.to_string();
                tokio::spawn(async move {
                    let mut cb = callback.lock().await;
                    (*cb)(&data);
                });
            }
        }
    }
}

impl Clone for Events {
    fn clone(&self) -> Self {
        let mut new_listeners = HashMap::new();

        for (event, callbacks) in &self.listeners {
            let cloned_callbacks = callbacks
                .iter()
                .map(|callback| Arc::clone(callback))
                .collect();

            new_listeners.insert(event.clone(), cloned_callbacks);
        }

        Self {
            listeners: new_listeners,
        }
    }
}

// Estructura para la conexi√≥n P2P
pub struct P2PConnection {
    sender: mpsc::Sender<ProtocolMessage>,
    receiver: Arc<Mutex<mpsc::Receiver<(PeerId, ProtocolMessage)>>>,
    peer_id: PeerId,
    is_dealer: bool,
    listeners: Arc<Mutex<Events>>,
    swarm: Arc<Mutex<Swarm<MyBehaviour>>>,
    from_swarm_tx: mpsc::Sender<(PeerId, ProtocolMessage)>,	
    to_swarm_rx: mpsc::Receiver<(PeerId, ProtocolMessage)>,
}

// El comportamiento de red combina Gossipsub y mDNS
#[derive(NetworkBehaviour)]
struct MyBehaviour {
    gossipsub: gossipsub::Behaviour,
    mdns: mdns::tokio::Behaviour,
}

impl P2PConnection {
    // Inicializa la conexi√≥n P2P
    pub async fn init() -> Result<Self, Box<dyn Error>> {
        let listeners = Arc::new(Mutex::new(Events::new()));

        let _ = tracing_subscriber::fmt()
            .with_env_filter(EnvFilter::from_default_env())
            .try_init();

        // Leer argumentos de la l√≠nea de comandos
        let args: Vec<String> = env::args().collect();
        let is_dealer = args.iter().any(|arg| arg == "--dealer"); // Verificar si el argumento dealer es "yes"

        // Puedes usar is_dealer para decidir el comportamiento del jugador
        if is_dealer {
            println!("El jugador es el dealer.");
        } else {
            println!("El jugador no es el dealer.");
        }

        // Canales para comunicaci√≥n con la aplicaci√≥n principal
        let (to_swarm_tx, mut to_swarm_rx) = mpsc::channel(32);
        let (mut from_swarm_tx, from_swarm_rx) = mpsc::channel(32);

        let from_swarm_rx = Arc::new(Mutex::new(from_swarm_rx));

        // Crear y configurar el swarm
        let swarm = Arc::new(Mutex::new(
            libp2p::SwarmBuilder::with_new_identity()
                .with_tokio()
                .with_tcp(
                    tcp::Config::default(),
                    noise::Config::new,
                    yamux::Config::default,
                )?
                .with_quic()
                .with_behaviour(|key| {
                    let message_id_fn = |message: &gossipsub::Message| {
                        let mut s = DefaultHasher::new();
                        message.data.hash(&mut s);
                        MessageId::from(s.finish().to_string())
                    };

                    let gossipsub_config = gossipsub::ConfigBuilder::default()
                        .heartbeat_interval(Duration::from_secs(10))
                        .validation_mode(gossipsub::ValidationMode::Strict)
                        .message_id_fn(message_id_fn)
                        .build()
                        .map_err(|msg| io::Error::new(io::ErrorKind::Other, msg))?;

                    let gossipsub = gossipsub::Behaviour::new(
                        MessageAuthenticity::Signed(key.clone()),
                        gossipsub_config,
                    )?;

                    let mdns = mdns::tokio::Behaviour::new(
                        mdns::Config::default(),
                        key.public().to_peer_id(),
                    )?;
                    Ok(MyBehaviour { gossipsub, mdns })
                })?
                .build(),
        ));

        let topic = IdentTopic::new("texas-holdem");
        swarm
            .lock()
            .await
            .behaviour_mut()
            .gossipsub
            .subscribe(&topic)?;

        // Configurar listeners
        swarm
            .lock()
            .await
            .listen_on("/ip4/0.0.0.0/udp/0/quic-v1".parse()?)?;
        swarm
            .lock()
            .await
            .listen_on("/ip4/0.0.0.0/tcp/0".parse()?)?;

        let peer_id = *swarm.lock().await.local_peer_id();
        println!("Local peer ID: {}", peer_id);

        Ok(Self {
            sender: to_swarm_tx,
            receiver: from_swarm_rx,
            peer_id,
            is_dealer,
            listeners,
            swarm,
            from_swarm_tx,
            to_swarm_rx,
        })
    }

    pub fn start(&self) {
        let swarm = Arc::clone(&self.swarm);
        let mut from_swarm_tx = self.from_swarm_tx.clone();
        let listeners = Arc::clone(&self.listeners);

        tokio::spawn(async move {
            // let mut swarm = swarm.lock().await;

            loop {
                let mut swarm_guard = swarm.lock().await;
                select! {
                    // Procesar eventos de Swarm
                    event = swarm_guard.select_next_some() => match event {
                        SwarmEvent::Behaviour(MyBehaviourEvent::Gossipsub(gossipsub::Event::Message {
                            propagation_source: peer_id,
                            message_id: _id,
                            message,
                        })) => {
                            println!("üì© Mensaje recibido de {}: {:?}", peer_id, message.data);
                            match serde_json::from_slice::<ProtocolMessage>(&message.data) {
                                Ok(protocol_message) => {
                                    if let Err(e) = from_swarm_tx.try_send((peer_id, protocol_message)) {
                                        println!("‚ùå Error enviando mensaje al canal interno: {:?}", e);
                                    }
                                }
                                Err(e) => println!("‚ùå Error deserializando mensaje: {:?}", e),
                            }
                        }
                        SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Discovered(peers))) => {
                            for (peer_id, _) in peers {
                                println!("üéâ Nuevo peer descubierto: {}", peer_id);
                                swarm_guard.behaviour_mut().gossipsub.add_explicit_peer(&peer_id);
                                listeners.lock().await.emit("peer_discovered", &peer_id.to_string());
                            }
                        }
                        _ => {}
                    },
                
                    // üí° NUEVO: Escuchar el canal `to_swarm_rx` para reenviar mensajes a la red
                    message = to_swarm_rx.next() => {
                        if let Some(msg) = message {
                            let topic = IdentTopic::new("texas-holdem");
                            let serialized_msg = serde_json::to_vec(&msg).expect("‚ùå Error serializando mensaje");
                
                            if let Err(e) = swarm.behaviour_mut().gossipsub.publish(topic, serialized_msg) {
                                println!("‚ùå Error publicando mensaje en Gossipsub: {:?}", e);
                            } else {
                                println!("‚úÖ Mensaje enviado a la red P2P");
                            }
                        }
                    }
                }
            }
        });
    }

    pub async fn on(&self, event: &str, callback: impl Fn(&str) + Send + Sync + 'static) {
        let mut listeners = self.listeners.lock().await;
        listeners.on(event, callback);
    }

    pub async fn emit(&self, event: &str, data: &str) {
        println!("Emitting event: {event} with data: {data}");
        let listeners = self.listeners.lock().await;
        listeners.emit(event, data);
    }

    // Obtener el peer ID local
    pub fn local_peer_id(&self) -> PeerId {
        self.peer_id
    }

    // Enviar un mensaje del protocolo
    pub async fn send_message(&self, message: ProtocolMessage) -> Result<(), Box<dyn Error>> {
        self.sender.clone().try_send(message)?;
        Ok(())
    }

    pub async fn receive_message(
        &self,
    ) -> Result<Option<(PeerId, ProtocolMessage)>, Box<dyn Error>> {
        Ok(self.receiver.lock().await.try_next()?)
    }

    // Funci√≥n de utilidad para convertir cualquier struct serializable en bytes
    pub fn serialize<T: Serialize>(data: &T) -> Result<Vec<u8>, Box<dyn Error>> {
        Ok(serde_json::to_vec(data)?)
    }

    pub fn serialize_canonical<T: CanonicalSerialize>(data: &T) -> Result<Vec<u8>, Box<dyn Error>> {
        let mut buffer = Vec::new();
        data.serialize(&mut buffer)?;
        Ok(buffer)
    }
    // Funci√≥n de utilidad para convertir bytes en un struct deserializable
    pub fn deserialize<T: DeserializeOwned>(bytes: &[u8]) -> Result<T, Box<dyn Error>> {
        Ok(serde_json::from_slice(bytes)?)
    }

    pub fn deserialize_canonical<T: CanonicalDeserialize>(
        bytes: &[u8],
    ) -> Result<T, Box<dyn Error>> {
        let mut reader = &bytes[..];
        let value = T::deserialize(&mut reader)?;
        Ok(value)
    }

    // Funci√≥n para obtener el valor de is_dealer
    pub fn is_dealer(&self) -> bool {
        self.is_dealer
    }
}
